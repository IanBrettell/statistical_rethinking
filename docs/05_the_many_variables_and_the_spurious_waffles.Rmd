---
title: "Chapter 5. The Many Variables & The Spurious Waffles"
date: '`r format(Sys.Date())`'
output:
  html_document:
    toc: true
    toc_float: true
    dev: 'svg'
    number_sections: false
    pandoc_args: --lua-filter=color-text.lua
    highlight: pygments
#output: html_notebook
#editor_options: 
#  chunk_output_type: inline
---

# Setup

```{r, message = F, warning=F}
library(here)
source(here::here("code/scripts/source.R"))
```

```{r}
slides_dir = here::here("docs/slides/L05")
```

# Text

```{r, echo = F, out.width='60%'}
knitr::include_graphics(file.path(slides_dir, '01.png'))
```

```{r, echo = F, out.width='60%'}
knitr::include_graphics(file.path(slides_dir, '02.png'))
```

Went to College in Atlanta. Has Waffle Houses. Always open. Sometimes there are two Waffle Houses. Other things in the South include Hurricanes.

```{r, echo = F, out.width='60%'}
knitr::include_graphics(file.path(slides_dir, '03.png'))
```

Because Waffle House is in the South, they invest in disaster preparedness, and even during a storm they stay open. 

```{r, echo = F, out.width='60%'}
knitr::include_graphics(file.path(slides_dir, '04.png'))
```

They even have a Waffle House index. If it's closed, it's a really bad storm. FEMA uses the index internally at FEMA.

```{r, echo = F, out.width='60%'}
knitr::include_graphics(file.path(slides_dir, '05.png'))
```

There are other things in the South. They have the highest divorce rates in the South. This sets up spurious correlations with anything in the South. So does Waffle House cause divorce? But in regression it's quite robust. Statistically, it's quite hard to get rid of it. But nature is full of stuff like this.

```{r, echo = F, out.width='60%'}
knitr::include_graphics(file.path(slides_dir, '06.png'))
```

Correlation is commonplace. Great example of the divorce rate in Maine with the per capita consumption of margarine. Lot's of things will cause a high correlation between variables, even if they have to relation. 

```{r, echo = F, out.width='60%'}
knitr::include_graphics(file.path(slides_dir, '07.png'))
```

Have the goal of both building it up and breaking it down. Can remove spurious correlations, and uncover masked associations you wouldn't see otheriwse. But adding variables can cause as much harm as good. You can actually hide associations as well. So you need a broader structure to think about this. 

Making decisions between good and bad will mean forming a framework to make them. The goal is to learn the back-door criterion.

```{r, echo = F, out.width='60%'}
knitr::include_graphics(file.path(slides_dir, '08.png'))
```

Waffle House doesn't cause divorce, but something does. The South is more religious. Lot's of things that are correlated with divorce rate. Marriage rate? Can't get divorce if you haven't been married, but could also be spurious. Might indicate that it's a society that views things favourably. 

```{r, echo = F, out.width='60%'}
knitr::include_graphics(file.path(slides_dir, '09.png'))
```

Another variable - median age at marriage, could also be causal. Which could it be? We want to now put both in the same model, which reveals that one of these is an imposter. 

```{r, echo = F, out.width='60%'}
knitr::include_graphics(file.path(slides_dir, '10.png'))
```
This is what multiple regression is for. We've got two questions in a model that has both questions. Do you get any predictive information from the second variable? 

```{r, echo = F, out.width='60%'}
knitr::include_graphics(file.path(slides_dir, '11.png'))
```

The arrows have directions to them; can be bidirectional. They're acyclic, so they don't loop. They're called graphs because they have nodes and edges. The associations are Bayesian networks, but they don't have interactions.

```{r, echo = F, out.width='60%'}
knitr::include_graphics(file.path(slides_dir, '12.png'))
```

We have here a plausible graph. How does A affect M? If the young are getting married too, then more people are getting married. Median age of marriage influences divorce rate because possibly young people make worse decisions. Is the arrow from M to D there? We want to tell the difference between A and D, and M and D. **NOTE**: when you're walking along the path, you can walk backwards along a path. 



```{r, echo = F, out.width='60%'}
knitr::include_graphics(file.path(slides_dir, '13.png'))
```

We want to tell the difference between these two things. Something causes waffle house, and something causes divorce. That thing is the South, and so they end up being correlated even though there's no causal relationship. 

`|` means "conditional on".

```{r, echo = F, out.width='60%'}
knitr::include_graphics(file.path(slides_dir, '14.png'))
```

Already know how to do these, just need to do extra stuff. Linear regression is a special type of Bayesian network where there's an outcome variable, which is assigned Gaussian probability with some mean that is conditional based on some variable, and a standard deviation. The `i`s are states. Have some intercepts. 

```{r, echo = F, out.width='60%'}
knitr::include_graphics(file.path(slides_dir, '15.png'))
```

Have to think harder about priors now. It help a lot by standardising the priors - converting them into Z-scores. If you make all your variables z-scores, you make you life easier. (But not in all cases.) 

When you standardise your predictors, you're setting your mean as 0. The regression line has to go through 0, and so alpha should be 0, We'll give it a Gaussian prior with a tight SD. Maybe should even be tighter. 

Slopes are a little harder. You don't want to use flat priors because you don't want it to think wildly impossible slopes are possible to start. That's why we do some prior predictive simulation.

```{r, echo = F, out.width='60%'}
knitr::include_graphics(file.path(slides_dir, '16.png'))
```

You can fit your model. You can run that model. `extract.prior` samples from the prior to simulate. Then pass it to `link` to create predictions based on the prior. Then you can plot the regression lines. 


```{r, echo = F, out.width='60%'}
knitr::include_graphics(file.path(slides_dir, '17.png'))
```

This is 50 regression lines from the prior. Standardised deviation of marriage. 2 SD is almost all. If your model thinks a possible divorce rate is outside the observable range of divorce rates, then they're bad. This prior allows really strong relationships. Allows it to govern nearly all the variation in divorce rate. But we'll move forward with this. This is the flattest prior you could justify scientifically. Priors by frequentists consider even crazier priors, just as vertical lines.

```{r, echo = F, out.width='60%'}
knitr::include_graphics(file.path(slides_dir, '18.png'))
```

Linear means additive, so the model makes a plane. You keep adding them together. There are four parameters. `$\alpha$, two slopes $\beta_1$ and $\beta_2$, adn the standard deviation $\sigma$.

```{r, echo = F, out.width='60%'}
knitr::include_graphics(file.path(slides_dir, '19.png'))
```

Here's the quap code, and we get a table of coefficients. Look for the mean, and as I promised, $\alpha$ is 0. ``bM` is about twice the size of the posterior value itself. No consistent relationship. Age of marriage however, is -.6, but now the posterior mass is entirely below 0. What's the lesson here? There's probably no causal relationship between marriage rate and divorce, and that's because it was confounded by age of marriage. 

```{r, echo = F, out.width='60%'}
knitr::include_graphics(file.path(slides_dir, '20.png'))
```

This shows all three models. Bottom is age of marriage only. The one with marriage rates in the middle. Then marriage rate and and age of marriage in the bottom.

```{r, echo = F, out.width='60%'}
knitr::include_graphics(file.path(slides_dir, '21.png'))
```

This is the graph. Once you know the median age of marriage, you get little extra information in marriage. But when you ad A, it does give you information. If you just wanted to make a prediction, M is useful, but if you wanted to change D, you need to change other things like A. 

You have to be clear about whether you're interesting in predicting things, or understanding the true nature of things. 

```{r, echo = F, out.width='60%'}
knitr::include_graphics(file.path(slides_dir, '22.png'))
```

How do we visualise models like this? Lots of ways. 
Usually the most useful way to visualise depends on the model. You want to think about what you're trying to communicate. The first are predictor residual plots, not that you need to do them, but good for understanding how these linear regressions works. 

```{r, echo = F, out.width='60%'}
knitr::include_graphics(file.path(slides_dir, '23.png'))
```
Purpose is to show how the association looks, having controlled for the other predictors. We want to calculate the intermediate states. Great for intuition but terrible for analysis. Never any statistical justification for running regression over residuals. Why? Gives you the wrong answer, because it gives you bias estimates. What to do instead? Multiple regressions. 

Recipe:

1. Regress a predictor, and find the extra variance left over, and look at the pattern of the relationship between the residuals and the outcome.

```{r, echo = F, out.width='60%'}
knitr::include_graphics(file.path(slides_dir, '24.png'))
```

Here's our first residual plot

```{r, echo = F, out.width='60%'}
knitr::include_graphics(file.path(slides_dir, '25.png'))
```

What are we looking at here? Marriage rate, standardised. THe distance from the regression line - the expected value of M conditional on A, is the residual. THe unexplained bit from the model. Highlighted some states with high residuals. Now we'll take the absolute distances for each point.


```{r, echo = F, out.width='60%'}
knitr::include_graphics(file.path(slides_dir, '26.png'))
```
Now take those residuals, and look at the correlation between the residuals of M and D. And you can see nothing. Shows you what the model is doing inside. If you do the multiple regresssion all at once, it handles all of that. If you do it this way you don't. But really good for intuition. Point of Maine with a really high divorce rate. 

```{r, echo = F, out.width='60%'}
knitr::include_graphics(file.path(slides_dir, '27.png'))
```

Still no explanation about why ME is so high. Now you can pivot A on M. 

```{r, echo = F, out.width='60%'}
knitr::include_graphics(file.path(slides_dir, '28.png'))
```

Then put those on the plot on the bottom. So now that you know M, there's considerable information in also knowing A. But the reverse is not true. 

```{r, echo = F, out.width='60%'}
knitr::include_graphics(file.path(slides_dir, '29.png'))
```

This is one of the things we mean. In observational studies like this one, there's no ethical intervention we can make. But we want to make causal information. Linear regression allows you to do that, but only if you have an idea of the causal relationship between the variables. To interpret, you need a causal framework. We'll have an example latter when controlling can *create* a confound.

These models are not magic. You shouldn't get cocky. This is the kind of study where you use average data. Quite a pathological dataset.

```{r, echo = F, out.width='60%'}
knitr::include_graphics(file.path(slides_dir, '30.png'))
```

Cases where you hold other predictor variables constant. All the code for generating them is in the text. In the real world we can't do that. If we're right in our DAG here, and we manipulate A, you'll also manipulate M as well. 

```{r, echo = F, out.width='60%'}
knitr::include_graphics(file.path(slides_dir, '31.png'))
```

Goals:
1. Figure out whether the approximation of the posterior works. Compare the predictions with the raw data. If they're different, they fail. 
1. It can inspire you to look at the cases that don't fit well, and figure out what you need to make better causal inferences.

```{r, echo = F, out.width='60%'}
knitr::include_graphics(file.path(slides_dir, '32.png'))
```

Diagonal is unity - perfect prediction. But there are states where they're making bad predictions, like ID. Has a very low D. That's why there's a mismatch. It's getting it really wrong. Why? The Mormons. They have a very low divorce rate. UT as well. 

```{r, echo = F, out.width='60%'}
knitr::include_graphics(file.path(slides_dir, '33.png'))
```

Another good thing regression can do is reveal spurious correlations. When there are two predictors that both influence the outcome in different directions, you can get the total causal effect between the two. This tends to arise where you have two predictors, and they act in different directions, and cancel each other out, so if you don't model both of them individually, it looks like they have no effect. 

Noise can also cause you not to see a relationship.

```{r, echo = F, out.width='60%'}
knitr::include_graphics(file.path(slides_dir, '34.png'))
```

Relationship between milk energy and how brainy they are? Intersted in things that are interested in what makes us unique. Primates are mammals, and some mammals have very highly energetic milk, like seals basically ooze butter. Primates in contrast carry their offspring on them. As a consequence, the energy density is lower. Human milk is not energetically rich. 75% of our brain mass is neocortex. Then the brainiest primate is *Cebus*. Can we see a signal of selection on milk energy from braininess?

```{r, echo = F, out.width='60%'}
knitr::include_graphics(file.path(slides_dir, '35.png'))
```

Sample of primate species. Pairs plot. Particularly strong correlation between the magnitude of body mass (log(mass)) is strongly correlated with neocortex. No particular strong relationship between `log(mass)` and `kcal.per.g`.
```{r, echo = F, out.width='60%'}
knitr::include_graphics(file.path(slides_dir, '36.png'))
```

We need to do some prior predictive simulation. Left is not a good prior. All we need to do to get the regression lines to live in the outcome space, we can contract $\alpha$ - should be about 0, and the slope should be about 0.5 to be tighter. If you standardise the predictor and outcome, Normal(0, 0.5) should keep you in the outcome space. 

```{r, echo = F, out.width='60%'}
knitr::include_graphics(file.path(slides_dir, '37.png'))
```

There's a slight relationship between brain and milk energy, and a slightly negative relationship with body mass. Look what happens when you include both in a model.

```{r, echo = F, out.width='60%'}
knitr::include_graphics(file.path(slides_dir, '38.png'))
```

Now very strong relationship between both. 

```{r, echo = F, out.width='60%'}
knitr::include_graphics(file.path(slides_dir, '39.png'))
```
You can see strong relationships, but only when they're both present in the model. This is the masking effect. One is positively related to the outcome, the other is negatively related to the outcome, and they're correlated with one another. Bigger primates need bigger brains, biger brains need more energy, bigger bodies need less because they're are longer developental times. THey're antagonistic effects, but correlated in same species. This sort of effect can happen a lot. 

```{r, echo = F, out.width='60%'}
knitr::include_graphics(file.path(slides_dir, '40.png'))
```

Fake data that causes this relationship. `U` is unobserved, some life history variable. Then the causal influence on each of those. This relationship is sufficient to create what we saw. 

```{r, echo = F, out.width='60%'}
knitr::include_graphics(file.path(slides_dir, '41.png'))
```

Often we have data that represents discrete categories. Want to include those, but they're not continuous. Useful variables because the mean varies, but can't add them as they are.

First is to create a dummy, and the next is almost always superior, and that's the index. 

```{r, echo = F, out.width='60%'}
knitr::include_graphics(file.path(slides_dir, '42.png'))
```

Take a categorical variable and convert them to indicator variables. They stand in for something. e.g. Kalahari height data, `0` means not `male`. 

```{r, echo = F, out.width='60%'}
knitr::include_graphics(file.path(slides_dir, '43.png'))
```

Height varies by sex, so you could include it in the model. The linear model looks like a continuous predictor, because you've coded it as 0 and 1, if effectively turns the parameter off and on, and adjusts the mean. Effectively makes two intercepts, one male, one female. `alpha` is the intercept for females, and `alpha + betaM` is the intercept for males. 

```{r, echo = F, out.width='60%'}
knitr::include_graphics(file.path(slides_dir, '44.png'))
```

Have to pick same number of priors for number of categories. Consequence is you end up assuming that one of the categories is less certain than all the others. 

```{r, echo = F, out.width='60%'}
knitr::include_graphics(file.path(slides_dir, '45.png'))
```

This is the better option. 

```{r, echo = F, out.width='60%'}
knitr::include_graphics(file.path(slides_dir, '46.png'))
```

```{r, echo = F, out.width='60%'}
knitr::include_graphics(file.path(slides_dir, '47.png'))
```

```{r, echo = F, out.width='60%'}
knitr::include_graphics(file.path(slides_dir, '48.png'))
```


